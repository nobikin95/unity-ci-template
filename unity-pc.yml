variables:
  BASE_PATH: "/home/ikame"
  APK_VERSION: "0.0.1"
  GIT_CLEAN_FLAGS: -ffdx -e Library/ -e Temp/

.common_before_script: &common_before_script
  - git config url."https://thanhtq:$GITLAB_CONFIG@gitlab.ikameglobal.com".insteadOf "https://gitlab.ikameglobal.com"
  - git submodule sync
  # Clone Assets/cicd to latest version (non-recursive)
  - git submodule update --init --remote --checkout Assets/cicd
  # Clone all other submodules recursively (exclude Assets/cicd)
  - git config --file .gitmodules --get-regexp path | awk '$2 != "Assets/cicd" {print $2}' | xargs -r -I {} git submodule update --init --recursive --checkout {}
  - git submodule foreach 'git reset --hard'
  - git submodule foreach 'git clean -fdx'

  # Unity version selection logic: Prefer higher or equal version
  - echo "Setting up environment..."
  - export PROJECT_UNITY_VERSION=$(grep "m_EditorVersion:" ProjectSettings/ProjectVersion.txt | awk '{print $2}')
  - echo "Unity version from ProjectSettings ${PROJECT_UNITY_VERSION}"
  - if [ -d "${BASE_PATH}/Unity/Hub/Editor" ]; then export UNITY_INSTALLED_VERSIONS=$(ls ${BASE_PATH}/Unity/Hub/Editor); fi
  - echo "Available Unity versions ${UNITY_INSTALLED_VERSIONS}"

  # Step 1: Try exact match first
  - export UNITY_VERSION=$(echo "$UNITY_INSTALLED_VERSIONS" | tr ' ' '\n' | grep -E "^${PROJECT_UNITY_VERSION}$" | head -n 1)
  - if [ -n "$UNITY_VERSION" ]; then
    echo "âœ“ Found exact match ${UNITY_VERSION}";
    fi

  # Step 2: If no exact match, try to find higher version in same major.minor
  - if [ -z "$UNITY_VERSION" ]; then
    echo "Exact version not found, looking for higher version in same major.minor...";
    export MAJOR_MINOR="${PROJECT_UNITY_VERSION%.*}";
    export UNITY_VERSION=$(echo "$UNITY_INSTALLED_VERSIONS" | tr ' ' '\n' | grep "^${MAJOR_MINOR}\." | sort -V | awk -v target="$PROJECT_UNITY_VERSION" '$0 > target {print; exit}');
    if [ -n "$UNITY_VERSION" ]; then
    echo "âœ“ Found higher version ${UNITY_VERSION} (>= ${PROJECT_UNITY_VERSION})";
    fi
    fi

  # Step 3: If no higher version, fallback to lower version in same major.minor
  - if [ -z "$UNITY_VERSION" ]; then
    echo "No higher version found, looking for lower version in same major.minor...";
    export UNITY_VERSION=$(echo "$UNITY_INSTALLED_VERSIONS" | tr ' ' '\n' | grep "^${MAJOR_MINOR}\." | sort -V | awk -v target="$PROJECT_UNITY_VERSION" '$0 < target {candidate=$0} END {print candidate}');
    if [ -n "$UNITY_VERSION" ]; then
    echo "âš  Using lower version ${UNITY_VERSION} (< ${PROJECT_UNITY_VERSION})";
    fi
    fi

  # Step 4: If still not found, exit with error
  - if [ -z "$UNITY_VERSION" ]; then
    echo "âŒ No matching Unity version found for ${PROJECT_UNITY_VERSION}";
    echo "Available versions ${UNITY_INSTALLED_VERSIONS}";
    exit 1;
    else
    echo "Using Unity version ${UNITY_VERSION}";
    fi
  - export UNITY_PATH="${BASE_PATH}/Unity/Hub/Editor/${UNITY_VERSION}/Editor/Unity"

  - if [ -z "$SLACK_BOT_TOKEN" ]; then echo "SLACK_BOT_TOKEN is not set"; else echo $SLACK_BOT_TOKEN; fi
  - if [ -z "$SLACK_CHANNEL_ID" ]; then echo "SLACK_CHANNEL_ID is not set"; else echo $SLACK_CHANNEL_ID; fi
  - if [ -z "$GITLAB_API_TOKEN" ]; then echo "GITLAB_API_TOKEN is not set"; else echo $GITLAB_API_TOKEN; fi
  - if [ -z "$SLACK_USER_IDS" ]; then echo "SLACK_USER_IDS is not set"; else echo $SLACK_USER_IDS; fi

  # Normalize SLACK_USER_IDS by removing spaces
  - if [ -n "$SLACK_USER_IDS" ]; then
    export SLACK_USER_IDS=$(echo "$SLACK_USER_IDS" | tr -d ' ');
    echo "Normalized SLACK_USER_IDS $SLACK_USER_IDS";
    fi

  # Extract the current MAJOR, MINOR, PATCH versions from APK_VERSION
  - export CURRENT_VERSION=$APK_VERSION
  - export MAJOR_VERSION=$(echo $CURRENT_VERSION | cut -d '.' -f1)
  - export MINOR_VERSION=$(echo $CURRENT_VERSION | cut -d '.' -f2)
  - export PATCH_VERSION=$(echo $CURRENT_VERSION | cut -d '.' -f3)
  - echo "Current Version $CURRENT_VERSION (Major $MAJOR_VERSION, Minor $MINOR_VERSION, Patch $PATCH_VERSION)"

build_pc_release:
  stage: build_pc
  rules:
    - if: '$CI_COMMIT_TAG =~ /^build-pc\/ver_*$/'
      when: on_success
    - if: '$CI_PIPELINE_SOURCE == "web"'
      when: manual
  before_script:
    - *common_before_script
    - export BUILD_TYPE="ðŸ–¥ï¸PC"
  script:
    # Update Scripting Symbol
    - chmod +x Assets/cicd/ci/update_scripting_symbols.sh
    - Assets/cicd/ci/update_scripting_symbols.sh --add_define_symbol="VERIFY_TOKEN" --remove_define_symbol=""

    - echo "Starting PC Build..."
    - mkdir -p Build/PC
    # Clean previous build
    - rm -rf Build/PC/*

    # Notify start
    - python3 Assets/cicd/ci/send_slack_webhook.py build_start project_name="$PROJECT_NAME" platform="PC" build_type="$BUILD_TYPE" version="$CURRENT_VERSION"

    # Build
    - echo "Running Unity build command..."
    - $UNITY_PATH -projectPath $CI_PROJECT_DIR -buildTarget Win64 -executeMethod BuildScript.BuildWindows -buildPath "Build/PC/${PROJECT_NAME}.exe" -logFile build_output.log -batchmode -nographics -silent-crashes -quit

    # Check result
    - if [ ! -f "Build/PC/${PROJECT_NAME}.exe" ]; then
      echo "Build failed! Output log:";
      tail -n 50 build_output.log;
      python3 Assets/cicd/ci/send_slack_webhook.py build_fail project_name="$PROJECT_NAME" platform="PC" build_type="$BUILD_TYPE" version="$CURRENT_VERSION";
      exit 1;
      fi

    - echo "Build succeeded. Compressing output..."

    # Zip the output
    - ZIP_NAME="${PROJECT_NAME}_PC_v${CURRENT_VERSION}.zip"
    - cd Build/PC
    # Zip everything in the folder (Game.exe, Game_Data, etc.)
    - zip -r "../$ZIP_NAME" .
    - cd ../..
    - ZIP_PATH="Build/$ZIP_NAME"

    - echo "Zip file created at $ZIP_PATH"

    # Upload to Slack
    - echo "Uploading to Slack..."
    - python3 Assets/cicd/ci/upload_slack.py "$ZIP_PATH" "PC Build - ${PROJECT_NAME} v${CURRENT_VERSION}" "$SLACK_USER_IDS"

    # Update APK_VERSION in GitLab CI/CD Variables
    - echo "Updating APK_VERSION in GitLab CI/CD Variables..."

    # Increase PATCH version
    - export PATCH_VERSION=$((PATCH_VERSION + 1))

    # Construct the new version in MAJOR.MINOR.PATCH format
    - export NEW_VERSION="${MAJOR_VERSION}.${MINOR_VERSION}.${PATCH_VERSION}"
    - echo "Building with new version $NEW_VERSION"

    - 'curl -X PUT -H "PRIVATE-TOKEN: $GITLAB_API_TOKEN" -d "value=$NEW_VERSION" "https://gitlab.ikameglobal.com/api/v4/projects/$CI_PROJECT_ID/variables/APK_VERSION"'

  artifacts:
    paths:
      - build_output.log
      - Build/*.zip
    expire_in: 1 day
